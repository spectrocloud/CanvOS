#!/usr/bin/env python3
"""
Curtin hooks script for MAAS deployment of Kairos/CanvOS images.

Responsibilities:
- Find the target installation disk from curtin/MAAS config.
- Locate the embedded Kairos dd image inside the extracted rootfs.
- dd the Kairos disk image onto the target disk (preserving A/B layout + boot menu).
- If MAAS user-data (cloudconfig) is present, write it into the Kairos OEM
  partition as /oem/userdata.yaml (via OEM label) so Kairos picks it up.
- If embedded userdata exists in the rootfs, merge it with MAAS userdata.
- Drop an 'apt' shim into the temporary /target so MAAS late extra_modules
  step ("apt install linux-modules-extra-...") always succeeds.
"""

import os
import sys
import textwrap

from curtin.config import load_command_config
from curtin.log import LOG, basicConfig, DEBUG
from curtin.util import load_command_environment, subp

# Adjust if your OEM label/path differ
OEM_LABEL = "COS_OEM"          # label of Kairos OEM partition in the dd image
OEM_MOUNTPOINT = "/mnt/kairos-oem"
OEM_CONFIG_PATH = "userdata.yaml"   # final path will be /oem/userdata.yaml


def find_target_disk(cfg, state):
    """
    Determine the target disk from curtin/MAAS config.

    Strategy:
      1. Follow the '/' mount from storage.config back to its disk.
      2. If that fails, use any 'disk' entry with a /dev/* path.
      3. If that fails, auto-discover from lsblk and pick the largest disk.
      4. Last resort: /dev/sda.
    """
    storage_config = cfg.get("storage", {}).get("config", [])
    LOG.info("Curtin storage config: %s", storage_config)

    # Index by id for quick lookup
    by_id = {e.get("id"): e for e in storage_config if "id" in e}

    # 1. Find the mount entry for '/' and walk its device chain back to a disk
    root_mount = None
    for entry in storage_config:
        if entry.get("type") == "mount" and entry.get("path") == "/":
            root_mount = entry
            break

    if root_mount:
        dev_id = root_mount.get("device")
        visited = set()
        while dev_id and dev_id in by_id and dev_id not in visited:
            visited.add(dev_id)
            entry = by_id[dev_id]
            if entry.get("type") == "disk" and entry.get("path", "").startswith("/dev/"):
                LOG.info("Using disk from root mount chain: %s", entry["path"])
                return entry["path"]
            dev_id = entry.get("device")

    # 2. Fall back to the first 'disk' entry with a /dev path
    for entry in storage_config:
        if entry.get("type") == "disk" and entry.get("path", "").startswith("/dev/"):
            LOG.info("Using first disk from storage config: %s", entry["path"])
            return entry["path"]

    # 3. Fallback: use lsblk to pick the largest disk
    try:
        out, _ = subp(["lsblk", "-ndo", "NAME,TYPE,SIZE"], capture=True)
        LOG.info("lsblk output:\n%s", out)
        best = None
        best_size = b"0"
        for line in out.splitlines():
            parts = line.split()
            if len(parts) < 3:
                continue
            name, typ, size = parts
            if typ != b"disk":
                continue
            dev = "/dev/" + name.decode()
            # crude but sufficient: compare size strings lexicographically
            if size > best_size:
                best_size = size
                best = dev
        if best:
            LOG.warning("Using largest disk from lsblk fallback: %s", best)
            return best
    except Exception as e:
        LOG.warning("lsblk-based disk detection failed: %s", e)

    # 4. Last resort
    LOG.warning("Target disk not found in config, using fallback /dev/sda")
    return "/dev/sda"


def find_kairos_image(state, target_root):
    """Locate the Kairos dd image inside the extracted rootfs or scratch."""
    candidates = [
        os.path.join(target_root, "usr/share/kairos/kairos-dd.img"),
        "/usr/share/kairos/kairos-dd.img",
        os.path.join(state.get("scratch", "/tmp"), "usr/share/kairos/kairos-dd.img"),
    ]

    for path in candidates:
        if os.path.exists(path):
            return path

    raise RuntimeError(
        "Kairos dd image not found. Searched:\n" +
        "\n".join(f"  - {p}" for p in candidates)
    )


def write_kairos_image(image_path, target_disk):
    """dd the Kairos raw disk image to the target disk."""
    if not os.access(image_path, os.R_OK):
        raise RuntimeError(f"Kairos dd image at {image_path} is not readable")

    size = os.path.getsize(image_path)
    LOG.info("Found Kairos dd image at %s (size: %s bytes)", image_path, size)

    subp(["sync"])
    LOG.info("Writing Kairos image to %s (this may take a while)...", target_disk)
    subp([
        "dd",
        f"if={image_path}",
        f"of={target_disk}",
        "bs=4M",
        "oflag=direct",
        "status=progress",
    ])
    subp(["sync"])
    LOG.info("Kairos dd image successfully written to %s", target_disk)


def fix_bootloader(target_disk):
    """
    Fix UEFI bootloader after dd operation.
    This ensures the UEFI firmware recognizes the boot entries.
    """
    LOG.info("Fixing bootloader for %s", target_disk)
    
    # Refresh partition table
    try:
        subp(["partprobe", target_disk])
        subp(["udevadm", "settle"])
    except Exception as e:
        LOG.warning("Failed to refresh partition table: %s", e)
    
    # Find EFI system partition (COS_GRUB label)
    efi_partition = None
    try:
        out, _ = subp(
            ["blkid", "-t", "LABEL=COS_GRUB", "-o", "device"],
            capture=True
        )
        efi_partition = out.strip()
        if efi_partition:
            LOG.info("Found EFI system partition: %s", efi_partition)
    except Exception as e:
        LOG.warning("blkid search for COS_GRUB failed: %s", e)
    
    if not efi_partition:
        LOG.warning("EFI system partition (COS_GRUB) not found, skipping bootloader fix")
        return
    
    # Mount EFI partition
    efi_mount = "/mnt/kairos-efi"
    os.makedirs(efi_mount, exist_ok=True)
    
    try:
        LOG.info("Mounting EFI partition %s to %s", efi_partition, efi_mount)
        subp(["mount", efi_partition, efi_mount])
        
        # Look for GRUB EFI file
        # Common locations: EFI/BOOT/bootx64.efi, EFI/kairos/grubx64.efi, etc.
        efi_paths = [
            os.path.join(efi_mount, "EFI/BOOT/bootx64.efi"),
            os.path.join(efi_mount, "EFI/kairos/grubx64.efi"),
            os.path.join(efi_mount, "EFI/BOOT/grubx64.efi"),
        ]
        
        grub_efi = None
        for path in efi_paths:
            if os.path.exists(path):
                grub_efi = path
                # Get relative path from EFI mount
                grub_efi_rel = os.path.relpath(path, efi_mount)
                LOG.info("Found GRUB EFI file: %s (relative: %s)", path, grub_efi_rel)
                break
        
        if not grub_efi:
            LOG.warning("GRUB EFI file not found in common locations, skipping efibootmgr")
            # Still try to reinstall GRUB if grub-install is available
            try:
                # Determine disk device (remove partition number)
                if "nvme" in target_disk:
                    # /dev/nvme0n1p1 -> /dev/nvme0n1
                    disk_dev = target_disk.rsplit("p", 1)[0]
                else:
                    # /dev/sda1 -> /dev/sda, /dev/vda1 -> /dev/vda
                    disk_dev = target_disk.rstrip("0123456789")
                
                LOG.info("Attempting to reinstall GRUB to %s", disk_dev)
                # Try grub-install (if available in the deployment environment)
                try:
                    subp(["grub-install", "--target=x86_64-efi", "--efi-directory=" + efi_mount, "--bootloader-id=kairos", "--removable", disk_dev])
                    LOG.info("GRUB reinstalled successfully")
                except Exception as e:
                    LOG.warning("grub-install failed (may not be available in deployment environment): %s", e)
            except Exception as e:
                LOG.warning("Failed to reinstall GRUB: %s", e)
        else:
            # Use efibootmgr to create/update UEFI boot entry
            try:
                # Determine disk device and partition number for efibootmgr
                # Use efi_partition (e.g., /dev/sda1) not target_disk (e.g., /dev/sda)
                if "nvme" in efi_partition:
                    # /dev/nvme0n1p1 -> /dev/nvme0n1, partition 1
                    disk_dev = efi_partition.rsplit("p", 1)[0]
                    part_num = efi_partition.rsplit("p", 1)[1]
                else:
                    # /dev/sda1 -> /dev/sda, partition 1
                    disk_dev = efi_partition.rstrip("0123456789")
                    part_num = efi_partition[len(disk_dev):]
                
                # Get relative path from EFI mount
                grub_efi_rel = os.path.relpath(grub_efi, efi_mount)
                
                # Create UEFI boot entry using efibootmgr
                # Format: efibootmgr -c -d /dev/sda -p 1 -L "Kairos" -l "\EFI\BOOT\bootx64.efi"
                # Note: Windows-style path separators in -l parameter
                efi_path_windows = grub_efi_rel.replace("/", "\\")
                
                LOG.info("Creating UEFI boot entry: disk=%s, partition=%s, path=%s", disk_dev, part_num, efi_path_windows)
                
                # Remove existing entries with same label (if any)
                try:
                    out, _ = subp(["efibootmgr"], capture=True)
                    for line in out.splitlines():
                        if "Kairos" in line or "kairos" in line:
                            # Extract boot number (e.g., "Boot0001")
                            import re
                            match = re.search(r"Boot(\d{4})", line)
                            if match:
                                boot_num = match.group(1)
                                LOG.info("Removing existing boot entry: Boot%s", boot_num)
                                subp(["efibootmgr", "-b", boot_num, "-B"], capture=True)
                except Exception as e:
                    LOG.warning("Failed to check/remove existing boot entries: %s", e)
                
                # Create new boot entry
                subp([
                    "efibootmgr",
                    "-c",
                    "-d", disk_dev,
                    "-p", part_num,
                    "-L", "Kairos",
                    "-l", efi_path_windows
                ])
                LOG.info("UEFI boot entry created successfully")
            except Exception as e:
                LOG.warning("efibootmgr failed (may not be available or firmware issue): %s", e)
                LOG.info("Bootloader files are in place, but UEFI boot entry may need manual configuration")
        
        subp(["sync"])
        
    finally:
        LOG.info("Unmounting EFI partition")
        try:
            subp(["umount", efi_mount])
        except Exception as e:
            LOG.warning("Failed to unmount EFI partition: %s", e)


def find_oem_partition(target_disk):
    """Refresh partition table and locate the OEM partition by label."""
    LOG.info("Refreshing partition table for %s", target_disk)
    try:
        subp(["partprobe", target_disk])
    except Exception as e:
        LOG.warning("partprobe failed on %s: %s", target_disk, e)

    try:
        subp(["udevadm", "settle"])
    except Exception as e:
        LOG.warning("udevadm settle failed: %s", e)

    LOG.info("Searching for OEM partition with label %s", OEM_LABEL)
    try:
        out, _ = subp(
            ["blkid", "-t", f"LABEL={OEM_LABEL}", "-o", "device"],
            capture=True
        )
        dev = out.strip()
        if dev:
            LOG.info("Found OEM partition %s", dev)
            return dev
    except Exception as e:
        LOG.warning("blkid search for OEM label %s failed: %s", OEM_LABEL, e)

    LOG.warning("OEM partition with label %s not found", OEM_LABEL)
    return None


def find_embedded_userdata(target_root):
    """Look for embedded userdata in the rootfs (e.g., from build-time)."""
    candidates = [
        os.path.join(target_root, "usr/share/kairos/userdata.yaml"),
        "/usr/share/kairos/userdata.yaml",
        os.path.join(target_root, "etc/kairos/userdata.yaml"),
        "/etc/kairos/userdata.yaml",
    ]
    
    for path in candidates:
        if os.path.exists(path):
            LOG.info("Found embedded userdata at %s", path)
            try:
                with open(path, "r") as f:
                    return f.read()
            except Exception as e:
                LOG.warning("Failed to read embedded userdata from %s: %s", path, e)
    
    return None


def merge_cloudconfig(embedded, maas_config):
    """
    Merge embedded userdata with MAAS userdata.
    MAAS userdata takes precedence for conflicting keys.
    """
    if not embedded:
        return maas_config
    if not maas_config:
        return embedded
    
    try:
        import yaml
        
        # Parse both configs
        embedded_dict = yaml.safe_load(embedded) if isinstance(embedded, str) else embedded
        maas_dict = yaml.safe_load(maas_config) if isinstance(maas_config, str) else maas_config
        
        if not isinstance(embedded_dict, dict):
            embedded_dict = {}
        if not isinstance(maas_dict, dict):
            maas_dict = {}
        
        # Merge: MAAS config takes precedence
        merged = embedded_dict.copy()
        merged.update(maas_dict)
        
        # Special handling for stages: merge lists if both have stages
        if "stages" in embedded_dict and "stages" in maas_dict:
            # Merge stages: combine stage lists, MAAS stages come after embedded
            merged["stages"] = {}
            merged["stages"].update(embedded_dict.get("stages", {}))
            # MAAS stages override embedded stages with the same name
            merged["stages"].update(maas_dict.get("stages", {}))
        
        return yaml.safe_dump(merged, default_flow_style=False)
    except Exception as e:
        LOG.warning("Failed to merge userdata configs, using MAAS config only: %s", e)
        return maas_config


def write_kairos_user_data(oem_dev, cloudconfig, target_root):
    """Write MAAS user-data (cloudconfig) into the Kairos OEM partition."""
    # Check for embedded userdata
    embedded_userdata = find_embedded_userdata(target_root)
    
    # Merge embedded and MAAS userdata if both exist
    if embedded_userdata and cloudconfig:
        LOG.info("Both embedded and MAAS userdata found, merging...")
        final_config = merge_cloudconfig(embedded_userdata, cloudconfig)
    elif embedded_userdata:
        LOG.info("Only embedded userdata found, using it")
        final_config = embedded_userdata
    elif cloudconfig:
        LOG.info("Only MAAS userdata found, using it")
        final_config = cloudconfig
    else:
        LOG.info("No userdata provided (neither embedded nor MAAS); skipping Kairos config injection")
        return

    if not oem_dev:
        LOG.warning(
            "Cannot write Kairos user-data: OEM partition not found. "
            "User-data will NOT be applied."
        )
        return

    os.makedirs(OEM_MOUNTPOINT, exist_ok=True)

    LOG.info("Mounting OEM partition %s to %s", oem_dev, OEM_MOUNTPOINT)
    subp(["mount", oem_dev, OEM_MOUNTPOINT])

    try:
        cfg_path = os.path.join(OEM_MOUNTPOINT, OEM_CONFIG_PATH)
        LOG.info("Writing user-data to %s", cfg_path)

        if isinstance(final_config, str):
            payload = final_config
        else:
            try:
                import yaml
                payload = yaml.safe_dump(final_config)
            except Exception:
                payload = str(final_config)

        payload = textwrap.dedent(payload).lstrip("\n")

        with open(cfg_path, "w") as f:
            f.write(payload)

        subp(["sync"])
        LOG.info("Kairos user-data written successfully")
    finally:
        LOG.info("Unmounting OEM partition %s", oem_dev)
        subp(["umount", OEM_MOUNTPOINT])


def find_persistent_partition(target_disk):
    """Find the persistent partition by label."""
    LOG.info("Searching for persistent partition with label COS_PERSISTENT")
    try:
        subp(["partprobe", target_disk])
        subp(["udevadm", "settle"])
    except Exception as e:
        LOG.warning("Failed to refresh partition table: %s", e)
    
    try:
        out, _ = subp(
            ["blkid", "-t", "LABEL=COS_PERSISTENT", "-o", "device"],
            capture=True
        )
        dev = out.strip()
        if dev:
            LOG.info("Found persistent partition %s", dev)
            return dev
    except Exception as e:
        LOG.warning("blkid search for COS_PERSISTENT failed: %s", e)
    
    return None


def copy_content_to_kairos(target_root, target_disk):
    """
    Copy content, edge-config, clusterconfig, and local-ui from Ubuntu rootfs
    to the Kairos image on the target disk.
    """
    content_source = os.path.join(target_root, "usr/share/kairos/content")
    edge_config_source = os.path.join(target_root, "usr/share/kairos/.edge_custom_config.yaml")
    clusterconfig_source = os.path.join(target_root, "usr/share/kairos/clusterconfig")
    local_ui_source = os.path.join(target_root, "usr/share/kairos")
    
    has_content = os.path.exists(content_source) and os.listdir(content_source)
    has_edge_config = os.path.exists(edge_config_source)
    has_clusterconfig = os.path.exists(clusterconfig_source) and os.listdir(clusterconfig_source)
    has_local_ui = os.path.exists(os.path.join(local_ui_source, "local-ui")) or \
                   os.path.exists(os.path.join(local_ui_source, "opt/spectrocloud"))
    
    if not (has_content or has_edge_config or has_clusterconfig or has_local_ui):
        LOG.info("No content files found in Ubuntu rootfs, skipping content copy")
        return
    
    # Find OEM and persistent partitions
    oem_dev = find_oem_partition(target_disk)
    persistent_dev = find_persistent_partition(target_disk)
    
    if not persistent_dev:
        LOG.warning("Persistent partition not found, cannot copy content")
        return
    
    # Mount persistent partition
    persistent_mount = "/mnt/kairos-persistent"
    os.makedirs(persistent_mount, exist_ok=True)
    
    try:
        LOG.info("Mounting persistent partition %s to %s", persistent_dev, persistent_mount)
        subp(["mount", persistent_dev, persistent_mount])
        
        # Copy content to persistent partition
        # Content goes to /usr/local/spectrocloud/bundle (persistent partition is mounted at /usr/local)
        if has_content:
            content_dest = os.path.join(persistent_mount, "spectrocloud/bundle")
            os.makedirs(content_dest, exist_ok=True)
            LOG.info("Copying content from %s to %s", content_source, content_dest)
            subp(["cp", "-a", f"{content_source}/.", content_dest])
            LOG.info("Content copied successfully to persistent partition")
        
        # Copy clusterconfig to persistent partition
        # Clusterconfig goes to /usr/local/spectrocloud/clusterconfig
        if has_clusterconfig:
            clusterconfig_dest = os.path.join(persistent_mount, "spectrocloud/clusterconfig")
            os.makedirs(clusterconfig_dest, exist_ok=True)
            LOG.info("Copying clusterconfig from %s to %s", clusterconfig_source, clusterconfig_dest)
            subp(["cp", "-a", f"{clusterconfig_source}/.", clusterconfig_dest])
            LOG.info("Clusterconfig copied successfully to persistent partition")
        
        # Copy local-ui to persistent partition
        # Local-ui goes to /usr/local/spectrocloud (which is /opt/spectrocloud via overlayfs)
        if has_local_ui:
            local_ui_dest = os.path.join(persistent_mount, "spectrocloud")
            os.makedirs(local_ui_dest, exist_ok=True)
            # Check if local-ui directory exists
            local_ui_dir = os.path.join(local_ui_source, "local-ui")
            if os.path.exists(local_ui_dir):
                LOG.info("Copying local-ui from %s to %s", local_ui_dir, local_ui_dest)
                subp(["cp", "-a", f"{local_ui_dir}/.", local_ui_dest])
            # Check if opt/spectrocloud exists (extracted local-ui)
            opt_spectrocloud = os.path.join(local_ui_source, "opt/spectrocloud")
            if os.path.exists(opt_spectrocloud):
                LOG.info("Copying opt/spectrocloud from %s to %s", opt_spectrocloud, local_ui_dest)
                subp(["cp", "-a", f"{opt_spectrocloud}/.", local_ui_dest])
            LOG.info("Local-ui copied successfully to persistent partition")
        
        subp(["sync"])
        
    finally:
        LOG.info("Unmounting persistent partition")
        try:
            subp(["umount", persistent_mount])
        except Exception as e:
            LOG.warning("Failed to unmount persistent partition: %s", e)
    
    # Copy edge-config to OEM partition
    if has_edge_config and oem_dev:
        os.makedirs(OEM_MOUNTPOINT, exist_ok=True)
        try:
            LOG.info("Mounting OEM partition %s to %s", oem_dev, OEM_MOUNTPOINT)
            subp(["mount", oem_dev, OEM_MOUNTPOINT])
            
            edge_config_dest = os.path.join(OEM_MOUNTPOINT, ".edge_custom_config.yaml")
            LOG.info("Copying edge-config from %s to %s", edge_config_source, edge_config_dest)
            subp(["cp", edge_config_source, edge_config_dest])
            subp(["sync"])
            LOG.info("Edge-config copied successfully")
        finally:
            try:
                subp(["umount", OEM_MOUNTPOINT])
            except Exception as e:
                LOG.warning("Failed to unmount OEM partition: %s", e)


def install_apt_shim(target_root):
    """
    Install a fake 'apt' inside the temporary /target so that MAAS'
    extra_modules step ('apt install linux-modules-extra-...') always
    succeeds. This only affects the throwaway /target tree, not the
    actual Kairos disk written to the target disk.
    """
    apt_path = os.path.join(target_root, "usr/bin/apt")
    os.makedirs(os.path.dirname(apt_path), exist_ok=True)

    LOG.info("Installing apt shim at %s to satisfy MAAS extra_modules", apt_path)

    shim = """#!/bin/sh
echo "apt shim called: $@" >&2
# Pretend everything is fine
exit 0
"""
    with open(apt_path, "w") as f:
        f.write(shim)

    os.chmod(apt_path, 0o755)
    LOG.info("apt shim installed")


def main():
    basicConfig(stream=sys.stderr, verbosity=DEBUG)
    LOG.info("Starting Kairos curtin hook")

    state = load_command_environment()
    cfg = load_command_config(None, state)

    target_root = state.get("target", "/target")
    target_disk = find_target_disk(cfg, state)

    LOG.info("Target root: %s", target_root)
    LOG.info("Target disk: %s", target_disk)

    # 1. Locate and write the Kairos dd image
    image_path = find_kairos_image(state, target_root)
    write_kairos_image(image_path, target_disk)
    
    # 1a. Fix bootloader after dd (ensure UEFI boot entries are recognized)
    fix_bootloader(target_disk)

    # 2. Copy content, edge-config, clusterconfig, and local-ui from Ubuntu rootfs to Kairos image
    copy_content_to_kairos(target_root, target_disk)

    # 3. Inject MAAS cloudconfig (and embedded userdata if present) into Kairos OEM if available
    oem_dev = find_oem_partition(target_disk)
    cloudconfig = cfg.get("cloudconfig")
    if cloudconfig:
        LOG.info("Cloudconfig found; injecting into Kairos OEM partition")
    else:
        LOG.info("No cloudconfig found in curtin config")

    write_kairos_user_data(oem_dev, cloudconfig, target_root)

    # 4. Install apt shim in temporary /target so that MAAS late extra_modules
    #    step ('apt install linux-modules-extra-...') does not fail.
    install_apt_shim(target_root)

    LOG.info("Kairos curtin hook completed successfully")
    return 0


if __name__ == "__main__":
    sys.exit(main())
